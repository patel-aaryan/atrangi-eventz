-- Migration: Create tickets table
-- Description: Stores individual purchased tickets for events
-- Note: This migration requires the orders table to exist first (created in orders migration)

-- Create enum type for ticket status
CREATE TYPE ticket_status AS ENUM ('pending', 'confirmed', 'checked_in');

CREATE TABLE IF NOT EXISTS tickets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Event relationship
    event_id UUID NOT NULL REFERENCES events(id) ON DELETE CASCADE,
    
    -- Order information (shared across all tickets in the same purchase)
    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE, -- Groups tickets from the same purchase
    order_number VARCHAR(50) NOT NULL, -- Human-readable order number (format: ATR-YYYY-XXXXXX)
    
    -- Order-level financial data (stored on each ticket for easy querying)
    order_subtotal DECIMAL(10, 2) NOT NULL, -- Subtotal before discount and fees
    order_discount DECIMAL(10, 2) DEFAULT 0.00, -- Total discount applied to order
    order_processing_fee DECIMAL(10, 2) DEFAULT 0.00, -- Stripe processing fee for entire order
    order_total DECIMAL(10, 2) NOT NULL, -- Total amount charged for entire order
    
    -- Ticket tier information (snapshot at time of purchase)
    tier_name VARCHAR(255) NOT NULL, -- Name of the ticket tier
    tier_index INTEGER NOT NULL, -- Index in the ticket_tiers array
    price_at_purchase DECIMAL(10, 2) NOT NULL, -- Price at time of purchase
    
    -- Attendee information (who will attend)
    attendee_first_name VARCHAR(255) NOT NULL,
    attendee_last_name VARCHAR(255) NOT NULL,
    attendee_email VARCHAR(255) NOT NULL,
    
    -- Buyer/Contact information (who purchased)
    buyer_first_name VARCHAR(255) NOT NULL,
    buyer_last_name VARCHAR(255) NOT NULL,
    buyer_email VARCHAR(255) NOT NULL,
    buyer_phone VARCHAR(50),
    
    -- Billing information
    billing_zip VARCHAR(20), -- Billing ZIP/postal code
    billing_address TEXT, -- Full billing address (optional, for future use)
    
    -- Ticket identification
    ticket_code VARCHAR(50) UNIQUE NOT NULL, -- Unique code for QR/check-in (e.g., "AE-2025-XXXXX") - auto-generated by trigger
    qr_code_data TEXT, -- QR code data/URL
    
    -- Payment information (ticket-level)
    amount_paid DECIMAL(10, 2) NOT NULL, -- Amount paid for this individual ticket
    currency VARCHAR(3) DEFAULT 'CAD',
    
    -- Stripe payment tracking (order-level, stored on each ticket)
    stripe_payment_intent_id VARCHAR(255), -- Stripe PaymentIntent ID
    stripe_charge_id VARCHAR(255), -- Stripe Charge ID
    stripe_payment_method_id VARCHAR(255), -- Stripe PaymentMethod ID
    payment_status VARCHAR(50), -- Stripe payment status (succeeded, pending, failed, etc.)
    
    -- Status and tracking
    status ticket_status DEFAULT 'pending',
    is_checked_in BOOLEAN DEFAULT false,
    checked_in_at TIMESTAMP WITH TIME ZONE,
    
    -- Timestamps
    purchased_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    CONSTRAINT valid_price CHECK (amount_paid >= 0),
    CONSTRAINT valid_tier_index CHECK (tier_index >= 0),
    CONSTRAINT valid_order_subtotal CHECK (order_subtotal >= 0),
    CONSTRAINT valid_order_discount CHECK (order_discount >= 0),
    CONSTRAINT valid_order_processing_fee CHECK (order_processing_fee >= 0),
    CONSTRAINT valid_order_total CHECK (order_total >= 0)
);

-- Create indexes for better query performance
CREATE INDEX idx_tickets_event_id ON tickets(event_id);
CREATE INDEX idx_tickets_order_id ON tickets(order_id);
CREATE INDEX idx_tickets_order_number ON tickets(order_number);
CREATE INDEX idx_tickets_ticket_code ON tickets(ticket_code);
CREATE INDEX idx_tickets_status ON tickets(status);
CREATE INDEX idx_tickets_stripe_payment_intent ON tickets(stripe_payment_intent_id) WHERE stripe_payment_intent_id IS NOT NULL;
CREATE INDEX idx_tickets_stripe_charge ON tickets(stripe_charge_id) WHERE stripe_charge_id IS NOT NULL;
CREATE INDEX idx_tickets_payment_status ON tickets(payment_status) WHERE payment_status IS NOT NULL;
CREATE INDEX idx_tickets_attendee_email ON tickets(attendee_email);
CREATE INDEX idx_tickets_buyer_email ON tickets(buyer_email);
CREATE INDEX idx_tickets_purchased_at ON tickets(purchased_at DESC);

-- Composite indexes for common queries
CREATE INDEX idx_tickets_event_status ON tickets(event_id, status);
CREATE INDEX idx_tickets_order_status ON tickets(order_id, status);

-- Add update trigger
CREATE TRIGGER update_tickets_updated_at BEFORE UPDATE ON tickets
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to generate unique ticket codes
CREATE OR REPLACE FUNCTION generate_ticket_code()
RETURNS TRIGGER AS $$
DECLARE
    event_year INTEGER;
    random_suffix VARCHAR(10);
    base_code VARCHAR(50);
    counter INTEGER := 0;
BEGIN
    -- Only generate if ticket_code is not already set
    IF NEW.ticket_code IS NOT NULL AND NEW.ticket_code != '' THEN
        RETURN NEW;
    END IF;
    
    -- Extract year from event start_date
    SELECT EXTRACT(YEAR FROM start_date) INTO event_year
    FROM events
    WHERE id = NEW.event_id;
    
    -- Generate unique code with retry logic to handle collisions
    LOOP
        -- Generate random 5-character alphanumeric suffix
        random_suffix := UPPER(
            SUBSTRING(
                MD5(RANDOM()::TEXT || NEW.id::TEXT || CURRENT_TIMESTAMP::TEXT || counter::TEXT),
                1,
                5
            )
        );
        
        -- Format: AE-YYYY-XXXXX (Atrangi Eventz - Year - Random)
        base_code := 'AE-' || event_year || '-' || random_suffix;
        
        -- Check if code already exists
        IF NOT EXISTS (SELECT 1 FROM tickets WHERE ticket_code = base_code) THEN
            NEW.ticket_code := base_code;
            EXIT;
        END IF;
        
        counter := counter + 1;
        -- Safety check to prevent infinite loop
        IF counter > 100 THEN
            RAISE EXCEPTION 'Failed to generate unique ticket code after 100 attempts';
        END IF;
    END LOOP;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-generate ticket code before insert
CREATE TRIGGER generate_ticket_code_trigger
    BEFORE INSERT ON tickets
    FOR EACH ROW
    EXECUTE FUNCTION generate_ticket_code();

-- Add comments for documentation
COMMENT ON TABLE tickets IS 'Individual purchased tickets for events. One row per ticket.';
COMMENT ON COLUMN tickets.order_id IS 'Groups multiple tickets from the same purchase transaction';
COMMENT ON COLUMN tickets.order_number IS 'Human-readable order number (format: ATR-YYYY-XXXXXX)';
COMMENT ON COLUMN tickets.order_subtotal IS 'Subtotal for entire order before discount and fees';
COMMENT ON COLUMN tickets.order_discount IS 'Total discount applied to entire order';
COMMENT ON COLUMN tickets.order_processing_fee IS 'Stripe processing fee for entire order';
COMMENT ON COLUMN tickets.order_total IS 'Total amount charged for entire order';
COMMENT ON COLUMN tickets.stripe_payment_intent_id IS 'Stripe PaymentIntent ID for tracking payment';
COMMENT ON COLUMN tickets.stripe_charge_id IS 'Stripe Charge ID after successful payment';
COMMENT ON COLUMN tickets.stripe_payment_method_id IS 'Stripe PaymentMethod ID used for payment';
COMMENT ON COLUMN tickets.payment_status IS 'Stripe payment status (succeeded, pending, failed, etc.)';
COMMENT ON COLUMN tickets.tier_name IS 'Name of the ticket tier at time of purchase';
COMMENT ON COLUMN tickets.tier_index IS 'Index position in the events.ticket_tiers JSONB array';
COMMENT ON COLUMN tickets.price_at_purchase IS 'Price paid for this ticket (may differ from current tier price)';
COMMENT ON COLUMN tickets.ticket_code IS 'Unique code for QR scanning and check-in (format: AE-YYYY-XXXXX)';
COMMENT ON COLUMN tickets.attendee_email IS 'Email of the person who will attend (may differ from buyer)';
COMMENT ON COLUMN tickets.buyer_email IS 'Email of the person who purchased the ticket';

-- Add composite foreign key to ensure order_number matches the order's order_number
-- Note: This requires the orders table to exist. Ensure orders migration runs before tickets migration.
ALTER TABLE tickets
    ADD CONSTRAINT fk_tickets_order_number
    FOREIGN KEY (order_id, order_number) REFERENCES orders(id, order_number) ON DELETE CASCADE;
