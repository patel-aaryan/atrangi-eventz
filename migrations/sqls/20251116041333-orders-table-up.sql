-- Migration: Create orders table
-- Description: Stores order-level information for ticket purchases

-- Create enum type for order status
CREATE TYPE order_status AS ENUM ('pending', 'confirmed', 'cancelled', 'refunded');

CREATE TABLE IF NOT EXISTS orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Order identification
    order_number VARCHAR(50) UNIQUE NOT NULL, -- Human-readable order number (format: ATR-YYYY-XXXXXX) - auto-generated by trigger
    
    -- Financial data
    subtotal DECIMAL(10, 2) NOT NULL, -- Subtotal before discount and fees
    discount DECIMAL(10, 2) DEFAULT 0.00, -- Total discount applied to order
    processing_fee DECIMAL(10, 2) DEFAULT 0.00, -- Stripe processing fee for entire order
    total DECIMAL(10, 2) NOT NULL, -- Total amount charged for entire order
    currency VARCHAR(3) DEFAULT 'CAD',
    
    -- Buyer/Contact information (who purchased)
    buyer_first_name VARCHAR(255) NOT NULL,
    buyer_last_name VARCHAR(255) NOT NULL,
    buyer_email VARCHAR(255) NOT NULL,
    buyer_phone VARCHAR(50),
    
    -- Billing information
    billing_zip VARCHAR(20), -- Billing ZIP/postal code
    billing_address TEXT, -- Full billing address (optional, for future use)
    
    -- Promo code (if applicable)
    promo_code VARCHAR(50),
    discount_amount DECIMAL(10, 2) DEFAULT 0.00, -- Discount amount from promo code
    
    -- Stripe payment tracking
    stripe_payment_intent_id VARCHAR(255), -- Stripe PaymentIntent ID
    stripe_charge_id VARCHAR(255), -- Stripe Charge ID
    stripe_payment_method_id VARCHAR(255), -- Stripe PaymentMethod ID
    stripe_customer_id VARCHAR(255), -- Stripe Customer ID (if customer created)
    payment_status VARCHAR(50), -- Stripe payment status (succeeded, pending, failed, etc.)
    
    -- Status and tracking
    status order_status DEFAULT 'pending',
    
    -- Timestamps
    purchased_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    CONSTRAINT valid_subtotal CHECK (subtotal >= 0),
    CONSTRAINT valid_discount CHECK (discount >= 0),
    CONSTRAINT valid_processing_fee CHECK (processing_fee >= 0),
    CONSTRAINT valid_total CHECK (total >= 0),
    CONSTRAINT valid_discount_amount CHECK (discount_amount >= 0),
    CONSTRAINT valid_total_calculation CHECK (
        ABS(total - (subtotal - discount + processing_fee)) < 0.01
    )
);

-- Create indexes for better query performance
CREATE INDEX idx_orders_order_number ON orders(order_number);
CREATE INDEX idx_orders_status ON orders(status);

-- Create unique constraint on (id, order_number) for composite foreign key from tickets
CREATE UNIQUE INDEX idx_orders_id_order_number ON orders(id, order_number);
CREATE INDEX idx_orders_buyer_email ON orders(buyer_email);
CREATE INDEX idx_orders_purchased_at ON orders(purchased_at DESC);
CREATE INDEX idx_orders_stripe_payment_intent ON orders(stripe_payment_intent_id) WHERE stripe_payment_intent_id IS NOT NULL;
CREATE INDEX idx_orders_stripe_charge ON orders(stripe_charge_id) WHERE stripe_charge_id IS NOT NULL;
CREATE INDEX idx_orders_payment_status ON orders(payment_status) WHERE payment_status IS NOT NULL;

-- Composite indexes for common queries
CREATE INDEX idx_orders_status_purchased_at ON orders(status, purchased_at DESC);

-- Add update trigger
CREATE TRIGGER update_orders_updated_at BEFORE UPDATE ON orders
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to generate unique order numbers
CREATE OR REPLACE FUNCTION generate_order_number()
RETURNS TRIGGER AS $$
DECLARE
    current_year INTEGER;
    random_suffix VARCHAR(10);
    base_number VARCHAR(50);
    counter INTEGER := 0;
BEGIN
    -- Only generate if order_number is not already set
    IF NEW.order_number IS NOT NULL AND NEW.order_number != '' THEN
        RETURN NEW;
    END IF;
    
    -- Get current year
    current_year := EXTRACT(YEAR FROM CURRENT_TIMESTAMP);
    
    -- Generate unique number with retry logic to handle collisions
    LOOP
        -- Generate random 6-character alphanumeric suffix
        random_suffix := UPPER(
            SUBSTRING(
                MD5(RANDOM()::TEXT || NEW.id::TEXT || CURRENT_TIMESTAMP::TEXT || counter::TEXT),
                1,
                6
            )
        );
        
        -- Format: ATR-YYYY-XXXXXX (Atrangi Eventz - Year - Random)
        base_number := 'ATR-' || current_year || '-' || random_suffix;
        
        -- Check if number already exists
        IF NOT EXISTS (SELECT 1 FROM orders WHERE order_number = base_number) THEN
            NEW.order_number := base_number;
            EXIT;
        END IF;
        
        counter := counter + 1;
        -- Safety check to prevent infinite loop
        IF counter > 100 THEN
            RAISE EXCEPTION 'Failed to generate unique order number after 100 attempts';
        END IF;
    END LOOP;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-generate order number before insert
CREATE TRIGGER generate_order_number_trigger
    BEFORE INSERT ON orders
    FOR EACH ROW
    EXECUTE FUNCTION generate_order_number();

-- Function to validate order number format
CREATE OR REPLACE FUNCTION validate_order_number_format()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.order_number !~ '^ATR-\d{4}-[A-Z0-9]{6}$' THEN
        RAISE EXCEPTION 'order_number must match format ATR-YYYY-XXXXXX';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to validate order number format
CREATE TRIGGER validate_order_number_format_trigger
    BEFORE INSERT OR UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION validate_order_number_format();

-- Note: Foreign key constraints from tickets.order_id to orders.id are defined inline in the tickets table migration

-- Add comments for documentation
COMMENT ON TABLE orders IS 'Order-level information for ticket purchases. One order can contain multiple tickets.';
COMMENT ON COLUMN orders.order_number IS 'Human-readable order number (format: ATR-YYYY-XXXXXX)';
COMMENT ON COLUMN orders.subtotal IS 'Subtotal for order before discount and fees';
COMMENT ON COLUMN orders.discount IS 'Total discount applied to order';
COMMENT ON COLUMN orders.processing_fee IS 'Stripe processing fee for entire order';
COMMENT ON COLUMN orders.total IS 'Total amount charged for entire order';
COMMENT ON COLUMN orders.stripe_payment_intent_id IS 'Stripe PaymentIntent ID for tracking payment';
COMMENT ON COLUMN orders.stripe_charge_id IS 'Stripe Charge ID after successful payment';
COMMENT ON COLUMN orders.stripe_payment_method_id IS 'Stripe PaymentMethod ID used for payment';
COMMENT ON COLUMN orders.payment_status IS 'Stripe payment status (succeeded, pending, failed, etc.)';
COMMENT ON COLUMN orders.promo_code IS 'Promo code applied to this order';
COMMENT ON COLUMN orders.discount_amount IS 'Discount amount from promo code';
COMMENT ON COLUMN orders.buyer_email IS 'Email of the person who purchased the tickets';
COMMENT ON COLUMN orders.status IS 'Current status of the order (pending, confirmed, cancelled, refunded)';
